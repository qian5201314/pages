<!doctype html>
<html lang="zh-CN">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>优化版运动检测高亮效果</title>
    <style>
      body {
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        height: 100vh;
        padding: 0;
        margin: 0;
        font-family: Arial, sans-serif;
        color: #fff;
        background-color: #000;
      }

      .container {
        position: relative;
        width: 100%;
        max-width: 500px;
        margin: 0 auto;
      }

      #video {
        display: none;
      }

      #canvas {
        width: 100%;
        border: 2px solid #444;
        border-radius: 8px;
      }

      .controls {
        display: flex;
        gap: 10px;
        justify-content: center;
        margin-top: 20px;
      }

      button {
        padding: 10px 15px;
        font-size: 16px;
        color: white;
        cursor: pointer;
        background-color: #4a2f8a;
        border: none;
        border-radius: 5px;
      }

      button:hover {
        background-color: #5f3ca8;
      }

      .sensitivity-control {
        width: 100%;
        max-width: 500px;
        margin-top: 15px;
        text-align: center;
      }

      .sensitivity-control label {
        display: block;
        margin-bottom: 5px;
      }

      .sensitivity-control input {
        width: 80%;
      }

      .loading {
        position: fixed;
        top: 0;
        left: 0;
        z-index: 100;
        display: flex;
        align-items: center;
        justify-content: center;
        width: 100%;
        height: 100%;
        background-color: rgba(0, 0, 0, 0.7);
      }

      .loading-text {
        font-size: 24px;
        color: white;
      }
    </style>
  </head>
  <body>
    <h1>优化版运动检测高亮效果</h1>
    <div class="container">
      <video id="video" autoplay playsinline></video>
      <canvas id="canvas"></canvas>
    </div>

    <div class="sensitivity-control">
      <label for="contrast">运动敏感度</label>
      <input type="range" id="contrast" min="30" max="150" step="1" value="60" />
    </div>

    <div class="sensitivity-control">
      <label for="brightness">高亮强度</label>
      <input type="range" id="brightness" min="1" max="3" step="0.1" value="1.5" />
    </div>

    <div class="sensitivity-control">
      <label for="minArea">最小检测区域</label>
      <input type="range" id="minArea" min="5" max="50" step="1" value="15" />
    </div>

    <div class="controls">
      <button id="startBtn">开始</button>
      <button id="switchCameraBtn">切换摄像头</button>
    </div>

    <div id="loading" class="loading">
      <div class="loading-text">加载中...</div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/tracking.js/1.1.3/tracking-min.js"></script>
    <script>
      document.addEventListener('DOMContentLoaded', function () {
        const video = document.getElementById('video')
        const canvas = document.getElementById('canvas')
        const ctx = canvas.getContext('2d')
        const startBtn = document.getElementById('startBtn')
        const switchCameraBtn = document.getElementById('switchCameraBtn')
        const contrastSlider = document.getElementById('contrast')
        const brightnessSlider = document.getElementById('brightness')
        const minAreaSlider = document.getElementById('minArea')
        const loadingElement = document.getElementById('loading')

        let stream = null
        let isProcessing = false
        let facingMode = 'environment' // 默认使用后置摄像头
        let previousFrame = null // 存储前一帧图像数据
        let motionHistory = [] // 存储运动历史用于速度计算
        let downsampledWidth = 160  // 降低处理分辨率
        let downsampledHeight = 120

        // 设置Canvas尺寸
        function setupCanvasSize() {
          canvas.width = video.videoWidth
          canvas.height = video.videoHeight
        }

        // 开始摄像头
        async function startCamera() {
          try {
            if (stream) {
              stopCamera()
            }

            loadingElement.style.display = 'flex'

            const constraints = {
              video: {
                facingMode: facingMode,
                width: { ideal: 640 },  // 降低分辨率
                height: { ideal: 480 }
              },
            }

            stream = await navigator.mediaDevices.getUserMedia(constraints)
            video.srcObject = stream

            return new Promise((resolve) => {
              video.onloadedmetadata = () => {
                setupCanvasSize()
                loadingElement.style.display = 'none'
                resolve()
              }
            })
          } catch (err) {
            console.error('摄像头访问错误:', err)
            alert('无法访问摄像头: ' + err.message)
            loadingElement.style.display = 'none'
          }
        }

        // 停止摄像头
        function stopCamera() {
          if (stream) {
            stream.getTracks().forEach((track) => track.stop())
            stream = null
          }
          isProcessing = false
        }

        // 处理视频帧
        function processFrame() {
          if (!isProcessing) return

          // 将视频帧绘制到Canvas
          ctx.drawImage(video, 0, 0, canvas.width, canvas.height)

          // 创建一个小分辨率的canvas用于运动检测
          const downsampledCanvas = document.createElement('canvas')
          downsampledCanvas.width = downsampledWidth
          downsampledCanvas.height = downsampledHeight
          const downsampledCtx = downsampledCanvas.getContext('2d')
          downsampledCtx.drawImage(video, 0, 0, downsampledWidth, downsampledHeight)

          // 获取小分辨率图像数据
          const downsampledImageData = downsampledCtx.getImageData(0, 0, downsampledWidth, downsampledHeight)
          const downsampledData = downsampledImageData.data

          // 创建当前帧的灰度图像用于运动检测
          const currentFrame = new Uint8ClampedArray(downsampledData.length / 4)
          for (let i = 0; i < downsampledData.length; i += 4) {
            // 计算灰度值 (使用亮度公式: 0.299R + 0.587G + 0.114B)
            const gray = 0.299 * downsampledData[i] + 0.587 * downsampledData[i + 1] + 0.114 * downsampledData[i + 2]
            currentFrame[i / 4] = gray
          }

          // 获取图像数据用于显示
          const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height)
          const data = imageData.data

          // 运动检测和高亮处理
          if (previousFrame) {
            // 获取运动敏感度设置
            const motionThreshold = parseInt(contrastSlider.value)
            
            // 获取最小检测区域设置
            const minArea = parseInt(minAreaSlider.value)
            
            // 创建运动区域标记数组
            const motionMap = new Array(currentFrame.length).fill(0)
            
            // 检测运动像素
            for (let i = 0; i < currentFrame.length; i++) {
              const diff = Math.abs(currentFrame[i] - previousFrame[i])
              if (diff > motionThreshold) {
                motionMap[i] = 1
              }
            }
            
            // 简单的区域过滤，忽略小面积运动
            let motionCount = 0
            for (let i = 0; i < motionMap.length; i++) {
              if (motionMap[i] === 1) {
                motionCount++
              }
            }
            
            // 如果运动区域太小，则忽略
            if (motionCount >= minArea) {
              // 处理每个像素
              for (let i = 0; i < data.length; i += 4) {
                // 计算在小分辨率图像中的对应位置
                const x = Math.floor((i / 4) % canvas.width * downsampledWidth / canvas.width)
                const y = Math.floor(Math.floor(i / 4 / canvas.width) * downsampledHeight / canvas.height)
                const downsampledIndex = y * downsampledWidth + x
                
                // 如果检测到运动
                if (downsampledIndex < motionMap.length && motionMap[downsampledIndex] === 1) {
                  // 计算运动速度 (基于差异值)
                  const diff = Math.abs(currentFrame[downsampledIndex] - previousFrame[downsampledIndex])
                  const speed = Math.min(1, diff / 100) // 归一化速度值 (0-1)
                  
                  // 获取高亮强度设置
                  const highlightIntensity = parseFloat(brightnessSlider.value)
                  
                  // 根据运动速度和高亮强度调整亮度 (速度越快越亮)
                  const brightness = Math.floor(speed * 255 * highlightIntensity)
                  
                  // 设置颜色 (使用金色，速度越快越亮)
                  data[i] = Math.min(255, brightness) // R
                  data[i + 1] = Math.floor(brightness * 0.8) // G
                  data[i + 2] = Math.floor(brightness * 0.2) // B
                } else {
                  // 静止区域保持原色但调暗
                  data[i] = Math.floor(data[i] * 0.3) // R
                  data[i + 1] = Math.floor(data[i + 1] * 0.3) // G
                  data[i + 2] = Math.floor(data[i + 2] * 0.3) // B
                }
              }
            } else {
              // 运动区域太小，不显示高亮
              for (let i = 0; i < data.length; i += 4) {
                // 静止区域保持原色但调暗
                data[i] = Math.floor(data[i] * 0.3) // R
                data[i + 1] = Math.floor(data[i + 1] * 0.3) // G
                data[i + 2] = Math.floor(data[i + 2] * 0.3) // B
              }
            }
          }
          
          // 保存当前帧用于下一帧比较
          previousFrame = currentFrame

          // 将处理后的图像数据绘制回Canvas
          ctx.putImageData(imageData, 0, 0)

          // 请求下一帧
          requestAnimationFrame(processFrame)
        }

        // 开始按钮事件
        startBtn.addEventListener('click', async function () {
          if (!isProcessing) {
            await startCamera()
            isProcessing = true
            startBtn.textContent = '停止'
            processFrame()
          } else {
            stopCamera()
            startBtn.textContent = '开始'
          }
        })

        // 切换摄像头按钮事件
        switchCameraBtn.addEventListener('click', async function () {
          facingMode = facingMode === 'user' ? 'environment' : 'user'
          if (isProcessing) {
            await startCamera()
            processFrame()
          }
        })

        // 调整滑块事件 - 无需重新启动处理
        contrastSlider.addEventListener('input', function () {
          // 处理会在下一帧自动应用新设置
        })

        brightnessSlider.addEventListener('input', function () {
          // 处理会在下一帧自动应用新设置
        })

        minAreaSlider.addEventListener('input', function () {
          // 处理会在下一帧自动应用新设置
        })

        // 页面卸载时停止摄像头
        window.addEventListener('beforeunload', stopCamera)

        // 隐藏加载提示
        loadingElement.style.display = 'none'
      })
    </script>
  </body>
</html>